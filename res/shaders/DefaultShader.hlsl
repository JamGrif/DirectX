/*
"SV_" means system value - written to by shader program, CPU can't modify them. Typically contain inputs / outputs from another shader stage, or generated by GPU during rasterization
"POSITION" means vertex buffer data
"SV_POSITION" provides a pixel position to the shader
"COLOR" for RGBA data given to a shader
"SV_TARGET" for writting from a pixel shader to a target texture
*/

struct DirectionalLight
{
    float4 Ambient;
    float4 Diffuse;
    float4 Specular;
    float3 Direction;
    float packing;
};

struct PointLight
{
    float4 Ambient;
    float4 Diffuse;
    float4 Specular;
    
    float3 Position;
    float Range;
    
    float3 Attenuation;
    float packing;
};

struct SpotLight
{
    float4 Ambient;
    float4 Diffuse;
    float4 Specular;
    
    float3 Position;
    float Range;
    
    float3 Direction;
    float Spot;
    
    float3 Attenuation;
    float packing;
};

struct Material
{
    float4 Ambient;
    float4 Diffuse;
    float4 Specular; // w = SpecPower
    float4 Reflect;
};


Texture2D texture0; 
SamplerState sampler0;



cbuffer PerObjectBUFFER
{
    matrix WVPMatrix;
    matrix WorldMatrix;
    matrix WorldInvTranspose;
    Material gMaterial;
};

cbuffer PerFrameBUFFER
{
    DirectionalLight gDirLight;
    float3 gEyePosW;
    float packing;
};

void CalculateDirectionalLight(Material mat, DirectionalLight L, float3 normal, float3 toEye, out float4 ambient, out float4 diffuse, out float4 spec);
void CalculatePointLight(Material mat, PointLight L, float3 pos, float3 normal, float3 toEye, out float4 ambient, out float4 diffuse, out float4 spec);
void CalculateSpotLight(Material mat, SpotLight L, float3 pos, float3 normal, float3 toEye, out float4 ambient, out float4 diffuse, out float4 spec);

struct VS_INPUT
{
    float3 PosL : POSITION;
    float2 texcoord : TEXCOORD;
    float3 NormalL : NORMAL;
};

struct VS_OUTPUT
{
    float4 PosH : SV_Position;
    float3 PosW : POSITION;
    float2 texcoord : TEXCOORD;
    float3 NormalW : NORMAL;
};



//Executed for eah vertex in a scene. Minimally returns in a 4-component position vector that gets rasterized into pixel position
VS_OUTPUT VShader(VS_INPUT input) //Vertex shader
{
    VS_OUTPUT output;
    
    //Transform to world space space
    output.PosW = mul(float4(input.PosL, 1.0f), WorldMatrix).xyz;
    output.NormalW = mul(input.NormalL, (float3x3) WorldInvTranspose);
    
    //Transform to homogeneous clip space
    output.PosH = mul(WVPMatrix, float4(input.PosL, 1.0f));
    
    output.texcoord = input.texcoord;
    
    return output;
    
   // 
   // VS_OUTPUT output;
   //
   // output.vPos = mul(WVPMatrix, input.vPos);
   // output.texcoord = input.texcoord;
   // 
   //
   //
   // return output;
}

//Executed for each pixel in a render target. Receives rasterized coordinates from previous shader stage. Returns a 4-component value for that pixel position (color)
float4 PShader (VS_OUTPUT vertex) : SV_Target
{
    
    //Interpolating normal can unnormalize it, so normalize it
    vertex.NormalW = normalize(vertex.NormalW);
    
    float3 toEyeW = normalize(gEyePosW - vertex.PosW);
    
    //Start with a sum of zero
    float4 ambient  = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse  = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec     = float4(0.0f, 0.0f, 0.0f, 0.0f);
    
    //Sum the light contribution from each light source
    float4 A, D, S;
    
    CalculateDirectionalLight(gMaterial, gDirLight, vertex.NormalW, toEyeW, A, D, S);
    ambient += A;
    diffuse += D;
    spec    += S;
    
    float4 litColour = ambient + diffuse + spec;
    
    //Common to take alpha from diffuse material
    litColour.a = gMaterial.Diffuse.a;
    
	//float4 color = texture0.Sample(sampler0, vertex.texcoord); //Apply texture to object
    
    return litColour;
    
    //float4 color = texture0.Sample(sampler0, vertex.texcoord); //Apply texture to object
    
    
    //return color;
    
}

void CalculateDirectionalLight(Material mat, DirectionalLight L, float3 normal, float3 toEye, out float4 ambient, out float4 diffuse, out float4 spec)
{
    //Init outputs
    ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    spec = float4(0.0f, 0.0f, 0.0f, 0.0f);
    
    //The light vector aims opposite the direction the light rays travel
    float3 lightVec = -L.Direction;
    
    //Add ambient term
    ambient = mat.Ambient * L.Ambient;
    
    //Add diffuse and specular, provided the surface is in the line of site of the light
    float diffuseFactor = dot(lightVec, normal);
    
    //Flatten to avoid dynamic branching
    [flatten]
    if (diffuseFactor > 0.0f)
    {
        float3 v = reflect(-lightVec, normal);
        float specFactor = pow(max(dot(v, toEye), 0.0f), mat.Specular.w);
        
        diffuse = diffuseFactor * mat.Diffuse * L.Diffuse;
        spec = specFactor * mat.Specular * L.Specular;

    }
    
    
    

}




//saturate function retricts values between 0.0 - 1.0